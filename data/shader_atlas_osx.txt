//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs

light basic.vs light.fs
single_light basic.vs single_light.fs

gbuffers basic.vs gbuffers.fs
deferred quad.vs deferred.fs
deferred_ws basic.vs deferred_ws.fs

ssao quad.vs ssao.fs
blur_ssao quad.vs blur_ssao.fs
HDR_tonemapping quad.vs HDR_tonemapping.fs

probe basic.vs probe.fs
irradiance quad.vs irradiance.fs

//UTILS
\functions_utils
mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
    // construct a scale-invariant frame
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}

// assume N, the interpolated vertex normal and
// WP the world position
//vec3 normal_pixel = texture2D( normalmap, uv ).xyz;
vec3 perturbNormal(vec3 N, vec3 WP, vec2 uv, vec3 normal_pixel)
{
    normal_pixel = normal_pixel * 255./127. - 128./127.;
    mat3 TBN = cotangent_frame(N, WP, uv);
    return normalize(TBN * normal_pixel);

}

// compute spot factor for spot lights
float get_spot_factor(vec3 u_light_vec, vec3 L, vec3 u_light_cone)
{
    float spotFactor = 1.0;
    float spotCosine = dot(normalize(u_light_vec),normalize(L));
    if (spotCosine >= u_light_cone.z) {
        spotFactor = pow(spotCosine,u_light_cone.y);
    }
    else { // The point is outside the cone of light from the spotlight.
        spotFactor = 0.0; // The light will add no color to the point.
    }
    return spotFactor;
}

// compute normal
vec3 compute_normal(sampler2D u_normal_texture, vec2 uv, vec3 v_normal, vec3 world_position)
{
    vec3 normal_pixel = texture2D( u_normal_texture, uv ).xyz; //in tangent space
    vec3 normal = normalize(v_normal);
    vec3 N = vec3(0,0,0);

    if(normal_pixel == vec3(0,0,0))
    {
        // if we don't have normal map
        N = normal;
    }
    else{
        // get normal map in normalmap space
        N = perturbNormal(normal, world_position, uv, normal_pixel);
    }
    return N;
}

// compute occlusion
float compute_occlusion(sampler2D u_occlusion_texture, sampler2D u_metallic_roughness_texture, vec2 uv)
{
    // occlusions info will be stored eather in occlusion_texture or in R channel of metallic_roughness_texture
    float occ_occ = texture2D(u_occlusion_texture, uv).x;
    float occ_m_r = texture2D(u_metallic_roughness_texture, uv).x;
    return occ_occ * occ_m_r;
}

// compute linear attenuation factor and normalize
float get_att_factor(float u_light_max_dist, float light_dist)
{
    float att_factor = u_light_max_dist - light_dist;
    att_factor /= u_light_max_dist;
    att_factor = max(att_factor, 0.0);            //ignore negative values
    att_factor *= pow(att_factor, 2.0);           //non linear attenuation
    
    return att_factor;
}

//compute shadow factor
float get_shadow_factor(mat4 u_shadow_viewproj, vec3 world_position, float u_shadow_bias, sampler2D u_light_shadowmap, int u_light_type)
{
    //project our 3D position to the shadowmap
    vec4 proj_pos = u_shadow_viewproj * vec4(world_position,1.0);

    //from homogeneus space to clip space
    vec2 shadow_uv = proj_pos.xy / proj_pos.w;

    //from clip space to uv space
    shadow_uv = shadow_uv * 0.5 + vec2(0.5);

    //get point depth [-1 .. +1] in non-linear space
    float real_depth = (proj_pos.z - u_shadow_bias) / proj_pos.w;

    //normalize from [-1..+1] to [0..+1] still non-linear
    real_depth = real_depth * 0.5 + 0.5;

    //read depth from depth buffer in [0..+1] non-linear
    float shadow_depth = texture2D( u_light_shadowmap, shadow_uv).x;

    //compute final shadow factor by comparing
    float shadow_factor = 1.0;
    
    //DIRECTIONAL LIGHT
    if(u_light_type == 1)
    {
        //it is outside on the sides
        if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 ||
            shadow_uv.y < 0.0 || shadow_uv.y > 1.0 )
            shadow_factor = 1.0;

        //it is before near or behind far plane
        if(real_depth < 0.0 || real_depth > 1.0)
            shadow_factor = 1.0;

    }
    
    //we can compare them, even if they are not linear
    if( shadow_depth < real_depth )
        shadow_factor = 0.0;
        
    return shadow_factor;
}

//PBR
\functions_PBR
#define RECIPROCAL_PI 0.3183098861837697
#define PI 3.14159265358979323846

// Normal Distribution Function using GGX Distribution
float D_GGX (const in float NoH, const in float linearRoughness )
{
    float a2 = linearRoughness * linearRoughness;
    float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
    return a2 / (PI * f * f);
}

// Fresnel term with colorized fresnel (f90 = 1)
float F_Schlick( const in float VoH, const in float f0)
{
    float f = pow(1.0 - VoH, 5.0);
    return f0 + (1.0 - f0) * f;
}

// Fresnel term with colorized fresnel
vec3 F_Schlick( const in float VoH, const in vec3 f0)
{
    float f = pow(1.0 - VoH, 5.0);
    return f0 + (vec3(1.0) - f0) * f;
}

// Geometry Term: Geometry masking/shadowing due to microfacets
float GGX(float NdotV, float k){
    return NdotV / (NdotV * (1.0 - k) + k);
}
    
float G_Smith( float NdotV, float NdotL, float roughness)
{
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return GGX(NdotL, k) * GGX(NdotV, k);
}

//this is the cook torrance specular reflection model
vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH )
{
    float a = roughness * roughness;

    // Normal Distribution Function
    float D = D_GGX( NoH, a );

    // Fresnel Function
    vec3 F = F_Schlick( LoH, f0 );

    // Visibility Function (shadowing/masking)
    float G = G_Smith( NoV, NoL, roughness );
        
    // Norm factor
    vec3 spec = D * G * F;
    spec /= (4.0 * NoL * NoV + 1e-6);

    return spec;
}

// Diffuse Reflections: Disney BRDF using retro-reflections using F term, this is much more complex!!
float Fd_Burley ( const in float NoV, const in float NoL, const in float LoH, const in float linearRoughness)
{
        float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;
        float lightScatter = F_Schlick(NoL, f90);
        float viewScatter  = F_Schlick(NoV, f90);
        return lightScatter * viewScatter * RECIPROCAL_PI;
}

vec3 compute_direct_light(vec3 u_camera_pos, vec3 world_position, vec3 L, vec3 N, vec4 color, float metalness, float roughness, float NoL){
    vec3 V = normalize( u_camera_pos - world_position);
    vec3 H = normalize( L + V );
    float NoH = clamp(dot(N,H), 0.0, 1.0);
    float NoV = clamp(dot(N,V), 0.0, 1.0);
    float LoH = clamp(dot(L,H), 0.0, 1.0);
    
    vec3 f0 = mix( vec3(0.5), color.xyz, metalness ); //we compute the reflection in base to the color and the metalness
    vec3 diffuseColor = (1.0 - metalness) * color.xyz; //metallic materials do not have diffuse
    
    vec3 Fr_d = specularBRDF(roughness, f0, NoH, NoV, NoL, LoH); //compute the specular

    // Here we use the Burley, but you can replace it by the Lambert.
    float linearRoughness = pow(roughness, 2.0);
    vec3 Fd_d = diffuseColor * Fd_Burley(NoV,NoL,LoH,linearRoughness);
    vec3 direct = Fr_d + Fd_d; //add diffuse and specular reflection
    return direct;
}

//HDR FUNCTIONS
\functions_color_space
vec3 degamma(vec3 c)
{
    return pow(c,vec3(2.2));
}

vec3 gamma(vec3 c)
{
    return pow(c,vec3(1.0/2.2));
}

vec3 Uncharted2ToneMapping(vec3 color)
{
    float A = 0.15;
    float B = 0.50;
    float C = 0.10;
    float D = 0.20;
    float E = 0.02;
    float F = 0.30;
    float W = 11.2;
    float exposure = 2.;
    color *= exposure;
    color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
    float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
    color /= white;
    return color;
}

vec3 lumaBasedReinhardToneMapping(vec3 color)
{
    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));
    float toneMappedLuma = luma / (1. + luma);
    color *= toneMappedLuma / luma;
    return color;
}


// irradiance
\functions_irradiance
const float Pi = 3.141592654;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;
struct SH9 { float c[9]; }; //to store weights
struct SH9Color { vec3 c[9]; }; //to store colors

SH9 SHCosineLobe(in vec3 dir, out SH9 sh) //SH9
{
    // Band 0
    sh.c[0] = 0.282095 * CosineA0;
    // Band 1
    sh.c[1] = 0.488603 * dir.y * CosineA1;
    sh.c[2] = 0.488603 * dir.z * CosineA1;
    sh.c[3] = 0.488603 * dir.x * CosineA1;
    // Band 2
    sh.c[4] = 1.092548 * dir.x * dir.y * CosineA2;
    sh.c[5] = 1.092548 * dir.y * dir.z * CosineA2;
    sh.c[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
    sh.c[7] = 1.092548 * dir.x * dir.z * CosineA2;
    sh.c[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
    
    return sh;
}

vec3 ComputeSHIrradiance(in vec3 normal, in SH9Color sh)
{
    // Compute the cosine lobe in SH, oriented about the normal direction
    SH9 shCosine;
    shCosine = SHCosineLobe(normal, shCosine);
    // Compute the SH dot product to get irradiance
    vec3 irradiance = vec3(0.0);
    for(int i = 0; i < 9; ++i)
        irradiance += sh.c[i] * shCosine.c[i];

    return irradiance;
}
vec3 computeLocalIndices(vec3 u_irr_end, vec3 u_irr_start, vec3 world_position, float u_irr_normal_distance, vec3 N, vec3 u_irr_delta)
{
    //computing nearest probe index based on world position
    vec3 irr_range = u_irr_end - u_irr_start;
    vec3 irr_local_pos = clamp(world_position-u_irr_start+N*u_irr_normal_distance, vec3(0.0), irr_range);

    //convert from world pos to grid pos
    vec3 irr_norm_pos = irr_local_pos / u_irr_delta;

    return irr_norm_pos;
}
vec3 computeIrr(vec3 local_indices, vec3 N, vec3 u_irr_dims, float u_num_probes, sampler2D u_probes_texture)
{
    //compute in which row is the probe stored
    float row = local_indices.x + local_indices.y * u_irr_dims.x + local_indices.z * u_irr_dims.x * u_irr_dims.y;

    //find the UV.y coord of that row in the probes texture
    float row_uv = (row + 1.0) / (u_num_probes + 1.0);
    
    SH9Color sh;
    //fill the coefficients
    const float d_uvx = 1.0 / 9.0;
    for(int i = 0; i < 9; ++i)
    {
        vec2 coeffs_uv = vec2((float(i)+0.5) * d_uvx, row_uv);
        sh.c[i] = texture2D(u_probes_texture, coeffs_uv).xyz;
    }

    //now we can use the coefficients to compute the irradiance
    vec3 irradiance = ComputeSHIrradiance(N, sh);
    return irradiance;
}

vec3 computeIrradiance(vec3 u_irr_end, vec3 u_irr_start, vec3 world_position, float u_irr_normal_distance, vec3 N, vec3 u_irr_delta, vec3 u_irr_dims, float u_num_probes, sampler2D u_probes_texture)
{
    // compute local indices
    vec3 irr_norm_pos = computeLocalIndices(u_irr_end,u_irr_start, world_position, u_irr_normal_distance, N, u_irr_delta);

    //round values as we cannot fetch between rows for now
    vec3 local_indices = floor(irr_norm_pos);
    
    //compute irradiance
    vec3 irradiance = computeIrr(local_indices,N, u_irr_dims, u_num_probes, u_probes_texture);
    return irradiance;
}

vec3 computeIrradianceInterpolated(vec3 u_irr_end, vec3 u_irr_start, vec3 world_position, float u_irr_normal_distance, vec3 N, vec3 u_irr_delta, vec3 u_irr_dims, float u_num_probes, sampler2D u_probes_texture)
{
    // compute local indices
    vec3 irr_norm_pos = computeLocalIndices(u_irr_end,u_irr_start, world_position, u_irr_normal_distance, N, u_irr_delta);
    //round values as we cannot fetch between rows for now
    vec3 local_indices = floor(irr_norm_pos);
    
    //now we have the interpolation factors
    vec3 factors = irr_norm_pos - local_indices;

    //local_indices points to Left,Bottom,Far
    vec3 indicesLBF = local_indices;
    
    //right bottom far index
    vec3 indicesRBF = local_indices;
    indicesRBF.x += 1.0; //from left to right

    vec3 indicesLTF = local_indices;
    indicesLTF.y += 1.0;
    
    vec3 indicesRTF = local_indices;
    indicesRTF.x += 1.0;
    indicesRTF.y += 1.0;

    vec3 indicesLBN = local_indices;
    indicesLBN.z += 1.0;

    vec3 indicesRBN = local_indices;
    indicesRBN.x += 1.0;
    indicesRBN.z += 1.0;

    vec3 indicesLTN = local_indices;
    indicesLTN.y += 1.0;
    indicesLTN.z += 1.0;
    
    vec3 indicesRTN = local_indices;
    indicesRTN.x += 1.0;
    indicesRTN.y += 1.0;
    indicesRTN.z += 1.0;

    //compute irradiance for every corner
    vec3 irrLBF = computeIrr( indicesLBF, N, u_irr_dims, u_num_probes, u_probes_texture);
    vec3 irrRBF = computeIrr( indicesRBF, N, u_irr_dims, u_num_probes, u_probes_texture);
    vec3 irrLTF = computeIrr( indicesLTF, N, u_irr_dims, u_num_probes, u_probes_texture);
    vec3 irrRTF = computeIrr( indicesRTF, N, u_irr_dims, u_num_probes, u_probes_texture);
    vec3 irrLBN = computeIrr( indicesLBN, N, u_irr_dims, u_num_probes, u_probes_texture);
    vec3 irrRBN = computeIrr( indicesRBN, N, u_irr_dims, u_num_probes, u_probes_texture);
    vec3 irrLTN = computeIrr( indicesLTN, N, u_irr_dims, u_num_probes, u_probes_texture);
    vec3 irrRTN = computeIrr( indicesRTN, N, u_irr_dims, u_num_probes, u_probes_texture);

    vec3 irrTF = mix( irrLTF, irrRTF, factors.x );
    vec3 irrBF = mix( irrLBF, irrRBF, factors.x );
    vec3 irrTN = mix( irrLTN, irrRTN, factors.x );
    vec3 irrBN = mix( irrLBN, irrRBN, factors.x );

    vec3 irrT = mix( irrTF, irrTN, factors.z );
    vec3 irrB = mix( irrBF, irrBN, factors.z );

    vec3 irr = mix( irrB, irrT, factors.y );
    
    return irr;
}

//----

\basic.vs


attribute vec3 a_vertex;
attribute vec3 a_normal;
attribute vec2 a_coord;
attribute vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;
varying vec4 v_color;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

attribute vec3 a_vertex;
attribute vec2 a_coord;
varying vec2 v_uv;

void main()
{
    v_uv = a_coord;
    gl_Position = vec4( a_vertex, 1.0 );
}

\instanced.vs

attribute vec3 a_vertex;
attribute vec3 a_normal;
attribute vec2 a_coord;

attribute mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;

void main()
{
    //calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
    v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
    
    //calcule the vertex in object space
    v_position = a_vertex;
    v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
    
    //store the texture coordinates
    v_uv = a_coord;

    //calcule the position of the vertex using the matrices
    gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}


\multi.fs

#version 330 core

varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

void main()
{
    vec2 uv = v_uv;
    vec4 color = u_color;
    color *= texture( u_texture, uv );

    if(color.a < u_alpha_cutoff)
        discard;

    vec3 N = normalize(v_normal);

    gl_FragData[0] = color;
    gl_FragData[1] = vec4(N,1.0);
}


\depth.fs

//#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
varying vec2 v_uv;

void main()
{
    float n = u_camera_nearfar.x;
    float f = u_camera_nearfar.y;
    float z = texture2D(u_texture,v_uv).x;
    float color = n * (z + 1.0) / (f + n - z * (f - n));
    gl_FragColor = vec4(color);
}

\flat.fs


uniform vec4 u_color;

void main()
{
	gl_FragColor = u_color;
}


\texture.fs

varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;
varying vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture2D( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	gl_FragColor = color;
}


\light.fs
#include "functions_utils"
#include "functions_PBR"

varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;
varying vec4 v_color;

uniform vec4 u_color;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_camera_position;

uniform vec3 u_light_color;
uniform vec3 u_light_position;
uniform vec3 u_ambient_light;
uniform float u_light_max_dist;
uniform int u_light_type;
uniform vec3 u_light_vec;
uniform vec3 u_light_cone;

uniform sampler2D u_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_emissive_texture;
uniform vec3 u_emissive_factor;
uniform sampler2D u_occlusion_texture;
uniform sampler2D u_metallic_roughness_texture;

uniform int u_light_cast_shadows;
uniform sampler2D u_light_shadowmap;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;

uniform int u_pbr;

void main()
{
    vec2 uv = v_uv;
    float spotFactor = 1.0;
    vec3 N = vec3(0,0,0);
    float shadowFactor = 1.0;
    vec3 L = vec3(0,0,0);
    vec3 direct = vec3(1.0);
    
    // compute normal
    N = compute_normal(u_normal_texture, uv, v_normal, v_world_position);
    
    // compute color
    vec4 color = u_color;
    color *= texture2D( u_texture, uv );

    if(color.a < u_alpha_cutoff)
        discard;
    
    // ambient light considering occlusions
    float occlusion = compute_occlusion(u_occlusion_texture,u_metallic_roughness_texture,uv);
    vec3 light = vec3(u_ambient_light) * occlusion; // ambient light
    
    // --compute light vector
    //DIRECTIONAL LIGHT
    if(u_light_type == 1)
    {
        L = u_light_vec;
    }
    else
    {
        // POINT LIGHT
        L = u_light_position - v_world_position;
        if(u_light_type == 2)
        {
            // SPOT LIGHT
            spotFactor = get_spot_factor(u_light_vec, L, u_light_cone);
        }
    }

    float light_dist = length(L);        //get distance
    L /= light_dist;                     //normalize L vector
    
    // compute linear attenuation factor and normalize
    float att_factor = get_att_factor(u_light_max_dist, light_dist);
    
    // compute shadow factor
    if(u_light_cast_shadows == 1)
        shadowFactor = get_shadow_factor(u_shadow_viewproj, v_world_position,  u_shadow_bias, u_light_shadowmap,u_light_type);

    float NdotL = clamp(dot(N, L), 0.0, 1.0);
    
    //PBR
    if(u_pbr == 1){
        float metalness = texture2D(u_metallic_roughness_texture, uv).z;
        float roughness = texture2D(u_metallic_roughness_texture, uv).y;
        direct = compute_direct_light(u_camera_position, v_world_position, L, N, color, metalness, roughness, NdotL);
    }
    
    light += (NdotL * u_light_color) * att_factor * spotFactor * shadowFactor * direct;
    
    color.xyz *= light;
    color.xyz += u_emissive_factor * (texture2D(u_emissive_texture, v_uv).xyz); //emissive light
    gl_FragColor = color;
}

\single_light.fs
#include "functions_utils"
#include "functions_PBR"

varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;
varying vec4 v_color;

uniform vec4 u_color;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_camera_position;

uniform vec3 u_ambient_light;
uniform int u_num_lights;

uniform sampler2D u_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_emissive_texture;
uniform vec3 u_emissive_factor;
uniform sampler2D u_occlusion_texture;
uniform sampler2D u_metallic_roughness_texture;

const int MAX_LIGHTS = 8;
uniform vec3 u_light_pos[MAX_LIGHTS];
uniform vec3 u_light_color[MAX_LIGHTS];
uniform float u_light_max_dist[MAX_LIGHTS];
uniform int u_light_type[MAX_LIGHTS];
uniform vec3 u_light_vec[MAX_LIGHTS];
uniform vec3 u_light_cone[MAX_LIGHTS];

uniform int u_pbr;

void main()
{
    vec2 uv = v_uv;
    vec3 N = vec3(0,0,0);
    vec3 direct = vec3(1.0);
    
    // compute normal
    N = compute_normal(u_normal_texture, uv, v_normal, v_world_position);
    
    // compute color
    vec4 color = u_color;
    color *= texture2D( u_texture, uv );

    if(color.a < u_alpha_cutoff)
        discard;
        
    // get metalness and roughness
    float metalness = texture2D(u_metallic_roughness_texture, uv).z;
    float roughness = texture2D(u_metallic_roughness_texture, uv).y;
    
    // ambient light considering occlusions
    float occlusion = compute_occlusion(u_occlusion_texture,u_metallic_roughness_texture,uv);
    vec3 light = vec3(u_ambient_light) * occlusion; // ambient light
    
    for(int i = 0; i < MAX_LIGHTS; ++i)
    {
        float spotFactor = 1.0;
        vec3 L = vec3(0,0,0);
        
        if(i < u_num_lights)
        {
            //DIRECTIONAL LIGHT
            if(u_light_type[i] == 1)
            {
                L = u_light_vec[i];
            }
            else
            {
                // POINT LIGHT
                L = u_light_pos[i] - v_world_position;
                if(u_light_type[i] == 2)
                {
                    // SPOT LIGHT
                    spotFactor = get_spot_factor(u_light_vec[i], L, u_light_cone[i]);
                }
            }

            float light_dist = length(L);        //get distance
            L /= light_dist;                     //normalize L vector
            
            // compute linear attenuation factor and normalize
            float att_factor = get_att_factor(u_light_max_dist[i], light_dist);

            float NdotL = clamp(dot(N, L), 0.0, 1.0);
            
            //PBR
            if(u_pbr == 1){direct = compute_direct_light(u_camera_position, v_world_position, L, N, color, metalness, roughness, NdotL);}
            
            light += (NdotL * u_light_color[i]) * att_factor * spotFactor * direct; // modify the amount of light
        }
    
    }
    color.xyz *= light;
    color.xyz += u_emissive_factor * (texture2D(u_emissive_texture, v_uv).xyz);
    gl_FragColor = color;
}

\gbuffers.fs
#include "functions_utils"

varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;
varying vec4 v_color;

uniform vec4 u_color;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform int u_use_dither;

uniform sampler2D u_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_emissive_texture;
uniform vec3 u_emissive_factor;
uniform sampler2D u_occlusion_texture;
uniform sampler2D u_metallic_roughness_texture;

//from https://github.com/hughsk/glsl-dither/blob/master/4x4.glsl
float dither4x4(vec2 position, float brightness)
{
  int x = int(mod(position.x, 4.0));
  int y = int(mod(position.y, 4.0));
  int index = x + y * 4;
  float limit = 0.0;

  if (x < 8) {
    if (index == 0) limit = 0.0625;
    if (index == 1) limit = 0.5625;
    if (index == 2) limit = 0.1875;
    if (index == 3) limit = 0.6875;
    if (index == 4) limit = 0.8125;
    if (index == 5) limit = 0.3125;
    if (index == 6) limit = 0.9375;
    if (index == 7) limit = 0.4375;
    if (index == 8) limit = 0.25;
    if (index == 9) limit = 0.75;
    if (index == 10) limit = 0.125;
    if (index == 11) limit = 0.625;
    if (index == 12) limit = 1.0;
    if (index == 13) limit = 0.5;
    if (index == 14) limit = 0.875;
    if (index == 15) limit = 0.375;
  }

  return brightness < limit ? 0.0 : 1.0;
}


void main()
{
    vec2 uv = v_uv;
    vec3 normal = vec3(0,0,0);

    // compute normal
    normal = compute_normal(u_normal_texture, uv, v_normal, v_world_position);
    
    // compute color
    vec4 color = u_color;
    color *= texture2D( u_texture, uv );

    if(color.a < u_alpha_cutoff)
        discard;
        
    // if use dithering is true and the pixel has transparency..
    if(u_use_dither == 1 && color.a < 0.9)
    {
        float dither_factor = dither4x4( gl_FragCoord.xy , color.a );
        if( dither_factor == 0.0 )
            discard;
    }
    
    // compute occulison
    float occlusion = compute_occlusion(u_occlusion_texture,u_metallic_roughness_texture,uv);
    
    // compute emissive light
    vec3 emissive = u_emissive_factor * (texture2D(u_emissive_texture, v_uv).xyz);
    
    // get metalness and roughness
    float roughness = texture2D(u_metallic_roughness_texture, uv).y;
    float metalness = texture2D(u_metallic_roughness_texture, uv).z;
    
    // store info in gbuffers
    gl_FragData[0] = vec4(color.xyz, roughness);
    gl_FragData[1] = vec4(normal * 0.5 + vec3(0.5), metalness); //normal map in range [0..1]
    gl_FragData[2] = vec4(emissive, occlusion);  //emissive light(RGB) and occlussion(alphs)
}

\deferred.fs
#include "functions_utils"
#include "functions_PBR"
#include "functions_color_space"
#include "functions_irradiance"

varying vec2 v_uv;
uniform vec4 u_color;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_camera_pos;

uniform vec3 u_light_color;
uniform vec3 u_light_position;
uniform vec3 u_ambient_light;
uniform float u_light_max_dist;
uniform int u_light_type;
uniform vec3 u_light_vec;
uniform vec3 u_light_cone;

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_ssao_texture;

uniform int u_light_cast_shadows;
uniform sampler2D u_light_shadowmap;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;

uniform vec2 u_iRes;
uniform mat4 u_inverse_viewprojection;

uniform int u_use_ssao;
uniform int u_use_ssao_blur;
uniform int u_use_hdr;
uniform int u_pbr;

uniform sampler2D u_probes_texture;
uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_dims;
uniform vec3 u_irr_delta;
uniform float u_num_probes;
uniform float u_irr_normal_distance;
uniform bool u_add_irradiance;
uniform bool u_interpolate_irradiance;
void main()
{
    vec2 uv = gl_FragCoord.xy * u_iRes.xy;
    float spotFactor = 1.0;
    float shadowFactor = 1.0;
    vec3 L = vec3(0,0,0);
    vec3 direct = vec3(1.0);
    vec3 ambient_light = u_ambient_light;
        
    // get info from extra texture
    vec4 extra = texture2D(u_extra_texture, uv);
    vec3 emissive = extra.xyz; // emissive light stored in RGB channel
    float occlusion = extra.a; // occlusion stored in Alpha channel
    
    // compute normal -> must be converted from 0..1 to -1..+1
    vec3 N = texture2D( u_normal_texture, uv ).xyz * 2.0 - vec3(1.0);
    N = normalize(N); //always normalize in case of data loss
    
    // get color
    vec4 color = vec4(texture2D( u_color_texture, uv ).xyz, 1.0);
    if(u_use_hdr == 1){color.xyz = degamma(color.xyz);}
        
    // get world position from depth
    float depth = float(texture2D( u_depth_texture, uv ).x);
    vec4 screen_pos = vec4( uv.x *2.0 -1.0, uv.y * 2.0 -1.0, depth*2.0-1.0, 1.0 ); // conv todo de -1 a 1
    vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
    vec3 world_position = proj_worldpos.xyz / proj_worldpos.w ;
    
    // get AO factor from ssao texture
    if(u_use_ssao == 1 || u_use_ssao_blur == 1){
        float ao_factor = texture2D(u_ssao_texture, uv).x;
        ao_factor = pow(ao_factor, 3.0);
        occlusion = ao_factor;
    }
    
    // compute irradiance
    if(u_add_irradiance)
    {
        vec3 irradiance = vec3(0.0);
        if(u_interpolate_irradiance)
        {
            irradiance = computeIrradianceInterpolated(u_irr_end, u_irr_start, world_position, u_irr_normal_distance, N, u_irr_delta, u_irr_dims, u_num_probes, u_probes_texture);
        }
        else{
            irradiance = computeIrradiance(u_irr_end,u_irr_start, world_position, u_irr_normal_distance, N, u_irr_delta, u_irr_dims, u_num_probes, u_probes_texture);}
        
        ambient_light = irradiance;
    }
    
    // ambient light considering occlusions
    vec3 light = vec3(ambient_light) * occlusion; // ambient light + occlusions
    
    // --compute light vector
    //DIRECTIONAL LIGHT
    if(u_light_type == 1)
    {
        L = u_light_vec;
    }
    else
    {
        // POINT LIGHT
        L = u_light_position - world_position;
        if(u_light_type == 2)
        {
            // SPOT LIGHT
            spotFactor = get_spot_factor(u_light_vec, L, u_light_cone);
        }
    }

    float light_dist = length(L);        //get distance
    L /= light_dist;                     //normalize L vector
    
    // compute linear attenuation factor and normalize
    float att_factor = get_att_factor(u_light_max_dist, light_dist);
    
    // compute shadow factor
    if(u_light_cast_shadows == 1)
        shadowFactor = get_shadow_factor(u_shadow_viewproj, world_position,  u_shadow_bias, u_light_shadowmap,u_light_type);

    float NdotL = clamp(dot(N, L), 0.0, 1.0);
    // PBR
    if(u_pbr == 1){
        // get roughness and metalness
        float roughness = texture2D(u_color_texture, uv).a;
        float metalness = texture2D(u_normal_texture, uv).a;
        direct = compute_direct_light(u_camera_pos, world_position, L, N, color, metalness, roughness, NdotL);
        }
        
    light += (NdotL * u_light_color) * att_factor * spotFactor * shadowFactor * direct;
    
    color.xyz *= light;
    color.xyz += emissive; // add emissive light
    gl_FragColor = color;
}

\deferred_ws.fs
#include "functions_utils"
#include "functions_PBR"
#include "functions_color_space"
#include "functions_irradiance"

varying vec2 v_uv;

uniform vec4 u_color;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_camera_pos;

uniform vec3 u_light_color;
uniform vec3 u_light_position;
uniform vec3 u_ambient_light;
uniform float u_light_max_dist;
uniform int u_light_type;
uniform vec3 u_light_vec;
uniform vec3 u_light_cone;

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_ssao_texture;

uniform int u_light_cast_shadows;
uniform sampler2D u_light_shadowmap;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;

uniform vec2 u_iRes;
uniform mat4 u_inverse_viewprojection;

uniform int u_use_ssao;
uniform int u_use_ssao_blur;
uniform int u_use_hdr;
uniform int u_pbr;

uniform sampler2D u_probes_texture;
uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_dims;
uniform vec3 u_irr_delta;
uniform float u_num_probes;
uniform float u_irr_normal_distance;
uniform bool u_add_irradiance;
uniform bool u_interpolate_irradiance;
void main()
{
    vec2 uv = gl_FragCoord.xy * u_iRes.xy;
    float spotFactor = 1.0;
    float shadowFactor = 1.0;
    vec3 L = vec3(0,0,0);
    vec3 direct = vec3(1.0);
    vec3 ambient_light = u_ambient_light;
    
    // get world position from depth
    float depth = float(texture2D( u_depth_texture, uv ).x);
    vec4 screen_pos = vec4( uv.x *2.0 -1.0, uv.y * 2.0 -1.0, depth*2.0-1.0, 1.0 ); // conv todo de -1 a 1
    vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
    vec3 world_position = proj_worldpos.xyz / proj_worldpos.w ;
    
    // get info from extra texture
    vec4 extra = texture2D(u_extra_texture, uv);
    vec3 emissive = extra.xyz; // emissive light stored in RGB channel
    float occlusion = extra.a; // occlusion stored in Alpha channel
    
    // compute normal -> must be converted from 0..1 to -1..+1
    vec3 N = texture2D( u_normal_texture, uv ).xyz * 2.0 - vec3(1.0);
    N = normalize(N); //always normalize in case of data loss
    
    // compute color
    vec4 color = vec4(texture2D( u_color_texture, uv ).xyz, 1.0);
    if(u_use_hdr == 1){color.xyz = degamma(color.xyz);}
    
    // get AO factor from ssao texture
    if(u_use_ssao == 1  || u_use_ssao_blur == 1){
        float ao_factor = texture2D(u_ssao_texture, uv).x;
        ao_factor = pow(ao_factor, 3.0);
        occlusion = ao_factor;
    }
    
    // compute irradiance
    if(u_add_irradiance)
    {
        vec3 irradiance = vec3(0.0);
        if(u_interpolate_irradiance)
        {
            irradiance = computeIrradianceInterpolated(u_irr_end, u_irr_start, world_position, u_irr_normal_distance, N, u_irr_delta, u_irr_dims, u_num_probes, u_probes_texture);
        }
        else{
            irradiance = computeIrradiance(u_irr_end,u_irr_start, world_position, u_irr_normal_distance, N, u_irr_delta, u_irr_dims, u_num_probes, u_probes_texture);
        }
        ambient_light = irradiance;
    }
    
    // ambient light considering occlusions
    vec3 light = vec3(ambient_light) * occlusion; // ambient light + occlusions
    
    // -- compute light vector
    //DIRECTIONAL LIGHT
    if(u_light_type == 1)
    {
        L = u_light_vec;
    }
    else
    {
        // POINT LIGHT
        L = u_light_position - world_position;
        if(u_light_type == 2)
        {
            // SPOT LIGHT
            spotFactor = get_spot_factor(u_light_vec, L, u_light_cone);
        }
    }

    float light_dist = length(L);        //get distance
    L /= light_dist;                     //normalize L vector
    
    // compute linear attenuation factor and normalize
    float att_factor = get_att_factor(u_light_max_dist, light_dist);
    
    // compute shadow factor
    if(u_light_cast_shadows == 1)
        shadowFactor = get_shadow_factor(u_shadow_viewproj, world_position,  u_shadow_bias, u_light_shadowmap,u_light_type);

    float NdotL = clamp(dot(N, L), 0.0, 1.0);
    // PBR
    if(u_pbr == 1){
        // get roughness and metalness
        float roughness = texture2D(u_color_texture, uv).a;
        float metalness = texture2D(u_normal_texture, uv).a;
        direct = compute_direct_light(u_camera_pos, world_position, L, N, color, metalness, roughness, NdotL);
    
    }
    
    light += (NdotL * u_light_color) * att_factor * spotFactor * shadowFactor * direct; // modify the amount of light
    
    color.xyz *= light;
    color.xyz += emissive; // add emissive light
    gl_FragColor = color;
}

\ssao.fs
#include "functions_utils"
#include "functions_PBR"

varying vec2 v_uv;

uniform mat4 u_viewprojection;
uniform vec3 u_points[64];

uniform sampler2D u_normal_texture;
uniform sampler2D u_depth_texture;

uniform vec2 u_iRes;
uniform mat4 u_inverse_viewprojection;

void main()
{
    vec2 uv = gl_FragCoord.xy * u_iRes.xy;

    // get depth
    float depth = float(texture2D( u_depth_texture, uv ).x);
    
    if(depth >= 1.0)
    {
        gl_FragColor = vec4(1.0);
        return;
    }
    
    // compute worl position from depth value
    vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
    vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
    vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;
    

    // compute normal -> must be converted from 0..1 to -1..+1
    vec3 N = texture2D( u_normal_texture, uv ).xyz * 2.0 - vec3(1.0);
    N = normalize(N); //always normalize in case of data loss
    
    //lets use 64 samples
    const int samples = 64;
    int num = samples; //num samples that passed the are outside

    //for every sample around the point
    for( int i = 0; i < samples; ++i )
    {
        
        // rotate point
        mat3 rotation_mat = cotangent_frame( N, world_position, uv);
        vec3 rotated_point = rotation_mat * u_points[i];
        
        //compute is world position using the random
        vec3 p = world_position + rotated_point * 10.0;
        
        //find the uv in the depth buffer of this point
        vec4 proj = u_viewprojection * vec4(p,1.0);
        proj.xy /= proj.w;   //convert to clipspace from homogeneous
        
        //apply a tiny bias to its z before converting to clip-space
        proj.z = (proj.z - 0.005) / proj.w;
        proj.xyz = proj.xyz * 0.5 + vec3(0.5); //to [0..1]
        
        //read p true depth
        float pdepth = texture2D(u_depth_texture, proj.xy).x;
        
        //compare true depth with its depth
        if( pdepth < proj.z ) //if true depth smaller, is inside
            num--; //remove this point from the list of visible
    }

    //finally, compute the AO factor as the ratio of visible points
    float ao = float(num) / float(samples);
    gl_FragColor = vec4(ao);
}

\blur_ssao.fs
#include "functions_color_space"

varying vec2 v_uv;
uniform sampler2D u_ssao_fbo;
uniform vec2 u_texture_size;

void main() {

    vec2 texelSize = 1.0 / u_texture_size;
    float result = 0.0;
    
    for (int x = -2; x < 2; ++x)
    {
        for (int y = -2; y < 2; ++y)
        {
            vec2 offset = vec2(float(x), float(y)) * texelSize;
            result += texture2D(u_ssao_fbo, v_uv + offset).r;
        }
    }
    
    gl_FragColor = vec4(result / vec4(4.0 * 4.0));
}


\HDR_tonemapping.fs
#include "functions_color_space"

varying vec2 v_uv;
uniform sampler2D u_texture;
uniform int u_tonemapper;

void main() {
    
    vec4 color = texture2D( u_texture, v_uv );
    if(u_tonemapper == 0){color.xyz = Uncharted2ToneMapping(color.xyz);}
    else if(u_tonemapper == 1){color.xyz = lumaBasedReinhardToneMapping(color.xyz);}
    vec3 rgb = gamma(color.xyz);
    gl_FragColor = vec4(rgb, color.a);
}

\probe.fs
#include "functions_irradiance"
varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;

uniform vec3 u_coeffs[9];


void main()
{
    SH9Color sh;
    sh.c[0] = u_coeffs[0];
    sh.c[1] = u_coeffs[1];
    sh.c[2] = u_coeffs[2];
    sh.c[3] = u_coeffs[3];
    sh.c[4] = u_coeffs[4];
    sh.c[5] = u_coeffs[5];
    sh.c[6] = u_coeffs[6];
    sh.c[7] = u_coeffs[7];
    sh.c[8] = u_coeffs[8];

    vec3 N = normalize(v_normal);
    vec4 color = vec4(ComputeSHIrradiance(N,sh), 1.0);
    gl_FragColor = color;
}

\irradiance.fs
#include "functions_irradiance"

varying vec2 v_uv;
varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;

uniform vec3 u_coeffs[9];

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_probes_texture;

uniform vec2 u_iRes;
uniform mat4 u_inverse_viewprojection;

uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_dims;
uniform vec3 u_irr_delta;
uniform float u_num_probes;
uniform float u_irr_normal_distance;
void main()
{
    vec2 uv = gl_FragCoord.xy * u_iRes.xy;

    // get depth
    float depth = float(texture2D( u_depth_texture, uv ).x);
    
    if(depth >= 1.0)
    {
        gl_FragColor = vec4(1.0);
        return;
    }
    
    // compute normal -> must be converted from 0..1 to -1..+1
    vec3 N = texture2D( u_normal_texture, uv ).xyz * 2.0 - vec3(1.0);
    N = normalize(N); //always normalize in case of data loss
    
    // compute worl position from depth value
    vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
    vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
    vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;
    
    // compute irradiance
    vec3 irradiance = computeIrradiance(u_irr_end,u_irr_start, world_position, u_irr_normal_distance, N, u_irr_delta, u_irr_dims, u_num_probes, u_probes_texture);
    
    // get color
    vec3 color = vec3(texture2D( u_color_texture, uv ).xyz) * irradiance;
    
    gl_FragColor = vec4(color, 1.0);
}
